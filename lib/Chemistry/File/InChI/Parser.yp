# Header section

%{

use strict;
use warnings;

use Chemistry::Atom;

%}

%%

# Rules section

# The grammar is taken from https://github.com/metamolecular/inchi-grammar/blob/master/grammar.ebnf, commit 74a8858, MIT license

string: prefix
      | prefix formula
      | prefix connections
      | prefix h_atoms
      | prefix formula connections
      | prefix formula h_atoms
      | prefix connections h_atoms
      | prefix formula connections h_atoms
      ;

formula: formula_first
            { return [ $_[1] ] }
       | formula formula_continuation
            { push @{$_[1]}, $_[2] }
       ;

connections: '/' 'c'
           | '/' 'c' graph
           | connections ';'
           | connections ';' graph
           ;

h_atoms: '/' 'h'
       | '/' 'h' hydrogens
       | h_atoms ';'
       | h_atoms ';' hydrogens
       ;

# Production 'tail' is merged to 'graph' and 'body' for simplicity.

graph: index bodies
        { _add_bonds( @_ ) }
     | count '*' index bodies
        { $_[0]->_add_bonds( $_[3], $_[4] ) }
     ;

body: '-' index
        { return $_[2] }
    | branches index
        { return [ @{$_[1]}, $_[2] ] }
    ;

bodies: body
      | bodies body
        { _add_bonds( @_ ); return $_[2] }
      ;

branch: '(' index ')'
        { return $_[2] }
      | '(' index branch_body ')'
        { return $_[2] }
      ;

branch_body: ',' index
                { return undef } # FIXME: What does this mean?
           | body
           | branch_body ',' index
                { return $_[1] }
           | branch_body body
                { return $_[1] }
           ;

branches: branch
            { return [ $_[1] ] }
        | branches branch
            { push @{$_[1]}, $_[2] }
        ;

hydrogens: vh_count
         | vh_count mh_counts
         | count '*' vh_count
         | count '*' vh_count mh_counts
         | mh_count
         ;

vh_count: virtual_hydrogens
        | vh_count ',' virtual_hydrogens
        ;

mh_count: mobile_hydrogens
        | mh_count mobile_hydrogens
        ;

mh_counts: ',' mh_count
         | mh_counts ',' mh_count
         ;

virtual_hydrogens: virtual_hydrogen_receivers 'H'
                    { $_[0]->_add_hydrogens( $_[1] ) }
                 | virtual_hydrogen_receivers 'H' count
                    { $_[0]->_add_hydrogens( $_[1], $_[2] ) }
                 ;

virtual_hydrogen_receivers: index
                            { return [ $_[1] ] }
                          | virtual_hydrogen_receivers ',' index
                            { push @{$_[1]}, $_[3] }
                          | virtual_hydrogen_receivers '-' index
                            { push @{$_[1]}, ($_[1]->[-1] + 1)..$_[3] }
                          ;

mobile_hydrogens: '(' 'H' comma_separated_indexes ')'
                | '(' 'H' '-' comma_separated_indexes ')'
                | '(' 'H' count '-' comma_separated_indexes ')'
                | '(' 'H' count comma_separated_indexes ')'
                ;

comma_separated_indexes: ',' index
                            { return [ $_[2] ] }
                       | comma_separated_indexes ',' index
                            { push @{$_[1]}, $_[3] }
                       ;

index: '1' | count ;

count: '1' digit
        {
            return join '', @_;
        }
     | count digit
        {
            return join '', @_;
        }
     | twoplus
     ;

digit: '0' | '1' | twoplus ;

twoplus: '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;

%%

# Footer section

sub parse
{
    my( $self, $string, $mol ) = @_;

    $self->YYData->{INPUT} = $string;
    $self->{USER}{MOL}     = $mol;
    $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error, yydebug => 1 );
}

sub _Lexer
{
    my( $self ) = @_;

    # If the line is empty and the input is originating from the file,
    # another line is read.
    if( !$self->YYData->{INPUT} && $self->{USER}{FILEIN} ) {
        my $filein = $self->{USER}{FILEIN};
        $self->YYData->{INPUT} = <$filein>;
        $self->{USER}{CHARNO} = 0;
    }

    # Prefix
    if( $self->YYData->{INPUT} =~ s/^(InChI=1S?)// ) {
        return ( 'prefix', $1 );
    }

    # Formula parts
    # TODO: Check Hill order, require counts > 1
    if( $self->YYData->{INPUT} =~ s/^([\/\.])(([A-Z][a-z]?\d*)+)// ) {
        my( $sep, $formula ) = ( $1, $2 );

        $self->{USER}{ATOM_MAP} = {}; # New atom map, reset if present

        while( $formula =~ /([A-Z][a-z]?)(\d*)/g ) {
            my( $element, $count ) = ( $1, $2 );
            next if $element eq 'H'; # H atoms will be added later
            $count = 1 unless $count;
            for (1..$count) {
                my $atom = Chemistry::Atom->new( symbol => $element );
                $self->{USER}{MOL}->add_atom( $atom );
                $self->{USER}{ATOM_MAP}{scalar( keys %{$self->{USER}{ATOM_MAP}} ) + 1} = $atom;
            }
        }

        if( $sep eq '/') {
            return ( 'formula_first', $formula );
        } else {
            return ( 'formula_continuation', $formula );
        }
    }

    # Any other character
    if( $self->YYData->{INPUT} =~ s/^(.)// ) {
        return ( $1, $1 );
    }

    return ( '', '' );
}

sub _Error
{
    my( $self ) = @_;
    print STDERR "ERROR!\n";
}

sub _add_bonds
{
    my( $self, $a, $b ) = @_;

    $a = $self->{USER}{ATOM_MAP}{$a};

    if( ref $b eq 'ARRAY' ) {
        for (@$b) {
            $self->{USER}{MOL}->new_bond( atoms => [ $a,
                                                     $self->{USER}{ATOM_MAP}{$_} ] );
        }
    } else {
        $b = $self->{USER}{ATOM_MAP}{$b};
        $self->{USER}{MOL}->new_bond( atoms => [ $a, $b ] );
    }
}

sub _add_hydrogens
{
    my( $self, $atoms, $count ) = @_;

    my @atoms = map { $self->{USER}{ATOM_MAP}{$_} }
                    ref $atoms ? @$atoms : ( $atoms );
    $count = 1 unless $count;
    for my $atom (@atoms) {
        for (1..$count) {
            my $H = Chemistry::Atom->new( symbol => 'H' );
            $self->{USER}{MOL}->new_bond( atoms => [ $atom, $H ] );
        }
    }
}

1;
